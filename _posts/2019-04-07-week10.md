Why I'd like to work in a Bazaar
--------------------------------

I'm really glad that I had a chance to read the cathedral and the Bazaar this semester, as I think that the idea behind the essay gets really close to the intrinsic usefulness of open source vs. proprietary software.  In the essay, Eric Raymond describes two types of development environments: The cathedral and the Bazaar.  The cathedral model is what we typically think about when software development comes to mind.  It consists of multiple people coming together and completing a piece of work with a religious fervor and attention to detail, painstakingly perfecting each stone in the finished monolith to be released as the first, complete version of the software they set out to create.  This can lead to some great code, sure, but sometimes attention to detail and a certain type of preconceived perfection can lead to an overall lack of creativity (do the chirstian, muslim, and hindu faiths not all have their own styles of art that they have perfected but fear to change and improve, as if those augmentations will break the perfectly balanced style that has already been created).  But how will we reach new artistic and practical heights without change?  This is where the Bazaar comes in, a ramshackle, thrown together meeting ground of 1000's of people from different backgrounds and areas of expertise who manage to turn nothing into an interesting, varied piece of work made better by the presence of freedom to deviate and to create something that may not even have been concieved of in the reverant cathedral.  This is the Bazaar's greatest strength, turning rules into suggestions, ultimate goals into stepping stones for even loftier achievements, and thousands of tiny imperfections into one beautiful mosaic of work.  When I put it that way, is it even a question as to which I would prefer?

Release Early.  Release Often.  And listen to your customers
------------------------------------------------------------

How do you release a cathedral before it is finished?  For the most part, creations such as these cannot be viewed until they are finished, and the little imperfections could take years of fundraising and specialty work to complete.  Not in the Bazaar.  From the moment that the first vendor sets up his or her shop, the Bazaar begins to take shape, and the customers can pass through.  One may say, "oh, I like these peaches, but why don't you sell mango, or apple?"  A quick and easy fix for the shop owner who can take this feedback and find the means to provide his customer with what they need.  If he can't, it is a simple request to ask his friend to take up the role of mango salesman, and another the role of apple salesman, and suddenly our Bazaar has trippled in size.  The customer may tell her friends how receptive this ragtag salesman was to her desire, and the next day, a new customer may come through looking for pears.  While the vendors do not sell pears, this new customer figures it is a good time to start growing pears of her own and provide them to others who may need them.  This is very similar to the flow of open source software development, where workers in the community can reach out for help with features they can't provide themselves, and users who desire new features can even provide them theirselves.  In this case, releasing early with almost nothing provides a route for desired users to suggest the features that will change the focus of the overall workspace in the future, further, listening to the consumers will keep them coming back, likely with new prospective customers.

Treating your users as co-developers is your least-hassle route to rapid code improvement and effective debugging.
------------------------------------------------------------------------------------------------------------------

This is a similar idea to what was discussed previously, but the two points together make for an important package deal.  Listening to these consumers isn't just about making the customers happy, but improving our Bazaar in the long run.  Who would there be to tell us the worms have infested the crop, or that a change in method has produced less flavorfull fruit?  These suggestions can be taken in real time, and as long as the customer knows we are reliable to fix the issues, they will continue coming back to a stronger, more reliable product.  How many times have you been annoyed by windows stealth bombing our computers with an update upon restarting?  If only windows would listen to us.

Free vs. Open Source Code
-------------------------

While the ideas of free and open source software are similar, they hold some differences in practice.  Free software if concerned with the freedom of the user - to read, change, and know the source code, so that nothing unwanted is being forced upon the user.  Open Source software models are concerned simply with the idea that open source is a better model to create strong and reliable code.  For the most part, Open Source agrees with all of the practices of the free software movement for designing code, and the two camps often work together on the same products, just with different sets of values.  However, free software proponents would not work on some code being developed by the open source camp that infringes on user freedom.  For example, free software proponents would not want or work on code that has unremovable effects not wanted by the user, such as spyware or restrictive development policies, whereas open source proponents may be ok with working on something like this as long as it uses the open source development model.

So where am I now?
------------------

On top of everything I have learned and contemplated this week, I've also been delving into the world of freeCodeCamp.  To start, me and my group have started working on updating the classes on font awesome to a new version by adding new descriptions, instructions, and changing the tests to reflect these changes.  I had a smaller role in this sector, by I personally have picked up an issue regarding writing recursion challenges for the website which I should have running by wednesday.  For the first challenge, I writing a challeneg that will require the user to write a recursive factorial function. In addition to this, I changed some grammar in the contributing.md and hope to get it pushed by the end of the week.  Looking forward to this next week of work.
